<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="img/Machine%20learning.png" type="image/x-icon">

<title>Machine Learning cơ bản</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
* {
  box-sizing: border-box;
}

body {
  font-family: Arial, Helvetica, sans-serif;
}

/* Style the header */
/*header {*/
/*  background-color: #29bdff;*/
/*  padding: 20px;*/
/*  text-align: center;*/
/*  font-size: 15px;*/
/*  color: white;*/
/*}*/

/* Create two columns/boxes that floats next to each other */
nav {
  float: left;
  width: 15%;
  height: auto; /* only for demonstration, should be removed */
  background: #f8f8f8;
  padding: 20px;
}
img{


  width : 80%;
  height : 70%;
  /*border: 3px solid green;*/

}
.center {
  margin: auto;
  width: 50%;
  /*border: 3px solid purple;*/
  padding: 10px;
  text-align: center;
}
/* Style the list inside the menu */
nav ul {
  list-style-type: none;
  padding: 0;
}

article {
  float: left;
  padding: 20px;
  width: 85%;
  background-color: #f8f8f8;
  height: auto; /* only for demonstration, should be removed */
}

/* Clear floats after the columns */
section::after {
  content: "";
  display: table;
  clear: both;
}
h1 {
   color: #29bdff;
}
/* Style the footer */
footer {
  background-color: #777;
  padding: 5px;
  text-align: center;
  color: white;
}

/* Responsive layout - makes the two columns/boxes stack on top of each other instead of next to each other, on small screens */
@media (max-width: 600px) {
  nav, article {
    width: 100%;
    height: auto;
  }
}
</style>
</head>
<body>
<div class="wrapper-masthead">
      <div class="container">
        <header  class="masthead clearfix" style="padding: 20px;color: #f8f8f8 ; background-color: #29bdff">
          <div class="site-info">
            <h2 class="site-name" style="text-align: center">Machine Learning cơ bản</h2>
            <p style="text-align: center;">Trong blog này, chúng ta sẽ tổng hợp toàn bộ kiến thức cơ bản về Học Máy</p>

              <a href="https://www.topcv.vn/xem-cv/AVNfC1QGVFkFAloCUgJfU1BRXVQGAQMKCA4BVAfe1b" target="_blank">About</a>

            <a href="https://github.com/nam157">Github</a>
          </div>
        </header>
      </div>
    </div>

<section>
  <nav>
    <ul  style="color: #29bdff" >
      <li><a href="index.html">I. Giới thiệu Học Máy</a></li><br>
        <li>
            <a href="#">II. Tiền xử lý dữ liệu</a>
        </li><br>
      <li><a href="regression.html">III. Hồi quy</a></li><br>
      <li><a href="#">IV. Phân loại - Phân cụm</a></li><br>
      <li><a href="#">V. Neural Network</a></li>
    </ul>
  </nav>

  <article>
    <h1>I. Khái niệm cơ bản</h1>

      <h4>
          0. Khái niệm Machine Learing
      </h4>
      <p>
          Một chương trình máy tính được cho là học từ kinh nghiệm E với tác vụ T và phép đo chất lượng P nào đó, nếu chất lượng của tác vụ T, được đo bởi P, cải thiện theo kinh nghiệm E. (Tom Mitchell, 1997)
      </p>

    <h4>
      1. Xác suất và thông kê trong Học Máy.
    </h4>
    <p>
      - Trong xác suất, chúng ta sẽ bắt đầu với model mô tả khả năng của sự kiện sẽ xảy ra. Sau đó dựa đoán khả năng xảy ra của sự kiện.
      <br>
      - Tóm lại có thể hiểu rằng là xây dựng 1 cái model dự đoán khả năng xảy ra trong tương lại dựa trên mô hình không có dữ liệu thực tế
      <br>
      - Trong thông kê thì tương phản với xác suất, thông kê chúng ta sẽ suy luận từ data hoặc mô hình dự trên dữ liệu thực tế để quan sát.
      <br>
      - Xác suất là đi từ model sang data trong khi Thông kê là đi từ data sang model.
    </p>
    <div class = 'center'>
      <img src="img/xs.png">
      <br>
      <p>Mối quan hệ giữa xác suất và thông kê trong Học Máy.</p>
      <a href="https://towardsdatascience.com/probability-vs-statistics-for-data-science-and-machine-learning-84f00bf67ce1">(Nguồn: https://towardsdatascience.com/probability-vs-statistics-for-data-science-and-machine-learning-84f00bf67ce1) </a>
    </div>
    <h4>
      2. Học có giám sát và Học không có giám sát (Supervised Learning - Unsupervised Learning)
    </h4>
    <p>
            - Supervised là thuật toán dựa đoán đầu ra của 1 hoặc nhiều mới dựa vào cặp (đầu vào, đầu ra) đã biết trước. Một tập biến đầu vào X= {X&sup1;,X&sup2;...X<sup>n</sup>} và tập đầu ra tương ứng Y= {Y&sup1;,Y&sup2;...Y<sup>n</sup>}
    </p>
    <div class = 'center'>
      <img src="img/spv.jpg">
      <br>
      <p>Ví dụ về học có giám sát</p>
    </div>
    <p>
      - Unsupervised là ngược lại với supervised chúng ta không biết kết quả đầu ra mà chỉ biết các vector đặc trưng đầu vào.<br>
      - Một cách toán học, Unsupervised learning là khi chúng ta chỉ có dữ liệu vào X mà không biết nhãn Y tương ứng.<br>
      - Giống như khi ta học, không có thầy cô giáo nào chỉ cho ta biết đó là chữ A hay chữ B. Cụm không giám sát được đặt tên theo nghĩa này.<br>
    </p>
    <div class = 'center'>
      <img src="img/unsver.jpg">
      <br>
      <p>Ví dụ về học không có giám sát</p>
    </div>
    <h4>
      3. Machine Learning và Deep Learning
    </h4>
    <p>
      - AI cho phép máy móc suy nghĩ mà không cần bất kỳ sự can thiệp nào của con người. Nó là một lĩnh vực rộng lớn của khoa học máy tính.
      - Machine Learning là tính năng của AI, cho phép các chuyên gia đào tạo cho AI để nó nhận biết các mẫu dữ liệu và dự đoán.<br>
      - Deep Learning là kỷ thuật nhỏ của ML, cho phép máy có thể tự đào tạo chính mình, và các phép tính toán học phức tạp hơn.
    </p>
    <div class = 'center'>
      <img src="img/AI-machine-learning-deep-learning.jpg">
      <br>
      <p>Mối quan hệ giữa AI,ML,DL</p>
      <br>
      <a href="https://content.techgig.com/understanding-the-difference-between-ai-ml-and-dl/articleshow/75493798.cms">Bài viết tham khảo</a>
    </div>
    <h4>
      4. Supervised Learning: Regression,Classification,DNN
    </h4>
    <p>
    <dl>
    <dt>Regression (Hồi quy):</dt>
      <dd>- Cơ bản là đầu ra của bài toán chính là dữ liệu liên tục</dd>
      <dd>- Một thuật toán Regression có thể dự đoán giá trị rời rạc nhưng giá trị rời rạc với đại lương nguyên </dd>
    <dd>- VD: Một căn nhà rộng x và có y phòng ngủ và cách trung tâm thành phố z sẽ có giá là bao nhiêu ?</dd>
    <dt>Classification</dt>
      <dd>- Kết quả đầu ra chính là dữ liệu rời rạc (nhãn hoặc xác suất nhãn) </dd>
    <dd>- Một thuật toán classification có thể dự đoán giá trị liên tục nhưng giá trị liên tục ở dạng xác suất đối với nhãn</dd>
    <dd>VD: Gmail xác định xem một email có phải là spam hay không; các hãng tín dụng xác định xem một khách hàng có khả năng thanh toán nợ hay không</dd>
    <dt>Deep neural network</dt>
    <dd>- Cơ bản có thể hiểu là mạng nơ-ron nông(Logistic Regression) được nâng cấp số lớp ẩn lên </dd>
    <dd>- DNN có thể thực hiện nhiệm vụ 2 bài toán classification và regression </dd>
    <dt>Điều quan trọng là phép đáng giá của Regression và Classification</dt>
    <dd>- Dự đoán Classification có thể đánh giá bằng độ chính xác (accuracy),...</dd>
    <dd>- Dự đoán Regression có thể đánh giá bằng root mean squared error hoặc các hàm chi phí khác </dd>
  </dl>
    </p>
    <h4>
      5. Unsupervised: Clustering,Auto Encoder Decoder, Luật Kết Hợp
    </h4>
    <dt>Clustering:</dt>
    <dd>- Nhiệm vụ là chia dữ liệu vào cũng 1 nhóm, và các điểm trong nhóm đó giống nhau và khác với điểm dữ liệu trong nhóm khác.Về cơ bản là nó là tập hợp các đối tượng trên cơ sở giống nhau và không giống nhau giữa chúng</dd>
    <dd>VD: Ví dụ: phân nhóm khách hàng dựa trên hành vi mua hàng. Điều này cũng giống như việc ta đưa cho một đứa trẻ rất nhiều mảnh ghép với các hình thù và màu sắc khác nhau, ví dụ tam giác, vuông, tròn với màu xanh và đỏ, sau đó yêu cầu trẻ phân chúng thành từng nhóm. Mặc dù không cho trẻ biết mảnh nào tương ứng với hình nào hoặc màu nào, nhiều khả năng chúng vẫn có thể phân loại các mảnh ghép theo màu hoặc hình dạng</dd>
    <div class = 'center'>
      <img src="img/cluster.jpeg">
      <br>
      <p>Ví dụ về phân cụm (3 cụm)</p>
    </div>
    <dt>Luật Kết Hợp:</dt>
    <dd>- Là bài toán mà khi chúng ta muốn khám phá ra một quy luật dựa trên nhiều dữ liệu cho trước</dd>
    <dd>VD: Ví như những khách hàng mua mặt hàng này sẽ mua thêm mặt hàng kia; hoặc khan giả xem phim này sẽ có xu hướng thích xem phim kia, dựa vào đó ta có thể xây dựng những hệ thống gợi ý khách hàng (Recommendation System) nhằm thúc đẩy nhu cầu mua sắm hoặc xem phim….</dd>
    <dt>Auto Encoder Decoder:</dt>
    <dd>- Autoencoder là một mô hình mạng nơ-ron có thể được sử dụng để học cách biểu diễn dữ liệu thô được nén. Một bộ Autoencoder có 2 phần đó là encoder và decoder sub-models. Encoder cố gằng nén đầu vào và Decoder cố gắng tái tạo đầu vào</dd>
    <h4>
      6. Clustering and Classification
    </h4>
    <p>
      - Clustering và Classification là 2 phương thức nhận dạng mẫu trong Học Máy. Mặc dù về cơ bản có thể nhận định khá là giống nhau tuy nhiên nó khác nhau trong thực tế.<br>
      - Classification là nó đi xác định các lớp cho trước và được gán nhãn sẵn và thuộc nhóm supervised learning. <br>
      - Clustering là nó xác định các điểm tương đồng giữa các đối tượng, nó sẽ nhóm theo các điểm tương đồng và khác với các nhóm kia và thuộc nhóm về unsupervised learning. <br>
    </p>
    <div class = 'center'>
      <img src="img/classif_clus.gif">
      <br>
      <p>Ví dụ trực quan về classification và clustering</p>
    </div>
      <h4>7. Học ngoại tuyến và Học trực tuyến</h4>
      <div>
          <dt>Học ngoại tuyến:</dt>
          <dd>- Hay còn được gọi học theo batch là cách học không có khả năng gia tăng, mô hình sẽ được huấn luyện với tất cả các dữ liệu khả dụng.</dd>
          <dd>- Học như này sẽ tốt rất nhiều thời gian và tài nguyên tính toán và hệ thống hoàn tất mọi việc học khi triển khai vào thực tế</dd>
          <dd>- Nếu như ta có thêm dữ liệu mới và muốn cập nhật thì ta cần phải đào tạo lại hệ thống mới bao gồm dữ liệu cũ và dữ liệu mới</dd>
          <dd>- May mắn là hiện tại việc đào tạo và đánh giá hệ thống không quá khó khăn và hoàn toàn tự động</dd>
          <dt>Học trực tuyến</dt>
          <dd>- Nó khác với lại học ngoại tuyến đó là mô hình có khả năng gia tăng tuần tự truyền dữ liệu theo từng điểm hoặc lô nhỏ (mini-batch)</dd>
          <dd>- Phương pháp còn phù hợp với tài nguyên tính toán bị giới hạn</dd>
          <dd>- Các thuật toán học trực tuyến cũng có thể huấn luyện các hệ thống có dữ liệu khổng lồ mà không chứa hết trong bộ nhớ chính đó còn được gọi cái tên là: học out-of-core</dd>
          <dd>- Tham số quan trọng của học trực tuyến đó tốc độ thích ứng dữ liệu đang thay đổi (learning rate)</dd>
      </div>
    <h4>
        8. Model based learning và Instance based learning
    </h4>
      <div>
          <dt>Instance-based learning</dt>
          <dd>- Còn được gọi là học trên mẫu và chúng ta có thể hiểu cách đơn giản là học thuộc lòng các mẫu </dd>
          <dd>- Để khai quát với các mẫu dữ liệu mới thì ta đi tính độ tương đồng so với dữ liệu mẫu đã học</dd>
          <div class="center">
              <img src="img/instance_based.jpg">
              <br>
              <p>Ví dụ về Instance-based learning</p>
          </div>

          <dt>Model-based learning</dt>
          <dd>- Còn được gọi là học theo mô hình, xây dựng một mô hình từ dự liệu rồi dùng mô hình đó để đưa ra dự đoán đó là một cách khác để khái quát hóa dữ liệu </dd>
          <div class = 'center'>
              <img src="img/model_based.jpg">
              <br>
              <p>Ví dự về Model-based learning</p>
          </div>
      </div>
    <h4>
      9. Chia tập dữ liệu: Training set - Validation set - Test set
    </h4>
    <dt>Training set(Tập huấn luyện):</dt>
    <dd>- Là tập dữ liệu để chạy thuật toán học</dd>
    <dt>Validation set(Tập phát triển):</dt>
    <dd>- Là tập dữ liệu được dùng để hiệu chỉnh các tham số, lựa chọn đặc trưng và quyết định các thay đổi liên quan đến thuật toán học. Đôi khi, nó còn được gọi là tập kiểm định chéo.</dd>
    <dt>Test set(Tập kiểm tra):</dt>
    <dd>- Là tập dữ liệu dùng để đánh giá chất lượng của thuật toán học, nhưng không được dùng để quyết định các thay đổi liên quan đến thuật toán học hay các tham số.</dd>
    <p>
      - Sau khi định nghĩa tập phát triển và tập kiểm tra, nhóm của bạn có thể thử nhiều ý tưởng khác nhau, ví dụ như các tham số khác nhau cho thuật toán học, để tìm ra ý tưởng tốt nhất. Tập phát triển và tập kiểm tra cho phép nhóm của bạn có thể đánh giá khả năng hoạt động của thuật toán một cách nhanh chóng.<br>
      - Nói cách khác, mục đích của tập phát triển và tập kiểm tra là hướng nhóm của bạn tới những thay đổi quan trọng nhất có thể làm để cải thiện trong hệ thống học máy.<br>
      - Lưu ý: Tập kiểm tra và tập phát triển này cần có cùng 1 phân phối<br>
      - Ta xây dựng một hệ thống dự đoán và hoạt động tốt trên tập phát triển tuy nhiên không hoạt động tốt trên tập kiểm tra. Nếu như tập phát triển và kiểm tra cùng phân phối thì chúng ta dễ dàng phát hiện ra vấn đề là quá khớp (overfit) cách xử lý thêm dữ liệu hoặc giảm mô hình,...
      Tuy nhiên, nếu ta gặp trường hợp không cùng phân phối thì sẽ rất khó khăn.<br>
      - Thông thường chia tập dữ liệu là 60/20/20. Tuy nhiên tùy vào trường hợp chúng ta chia dữ liệu sao cho hợp lý.
</p>
    <div class = 'center'>
      <img src="img/tapdl.jpg">
      <br>
      <p>Ví dụ về chia tập dữ liệu.</p>
    </div>

    <h4>
      10. Overfitting - Underfitting
    </h4>
    <dt>Overfitting:</dt>
    <dd>- Là trường hợp quá khớp với tập dữ liệu trainning có nghĩa là những điểm nhiễu trong tập dữ liệu training cũng học,
      trường hợp overfit xảy ra khi tập dữ liệu training quá nhỏ hoặc model có quá nhiều tham số.</dd>
    <dd>- Chi phí lỗi training error thấp mà validation error/test error quá cao thì điều có nghĩa tập dữ liệu overfit.</dd>
    <dd>- Overfitting xảy ra khi phương sai quá lớn</dd>
    <dd>- Để khắc phục vấn đề này thì có thể sử dụng: Regularization, Validation,Thêm dữ liệu training,...</dd>
    <dt>Underfitting:</dt>
    <dd>- Là trường hợp mô hình chưa khái quá hóa được dữ liệu traning cũng như chưa khái quan hóa tập dữ liệu mới.</dd>
    <dd>- Một mô hình học máy không phù hợp không phải là một mô hình phù hợp và sẽ hiển nhiên vì nó sẽ có hiệu suất kém trên dữ liệu đào tạo. Hoặc là mô hình quá nhỏ</dd>
    <dd>- Chi phí lỗi traning error và validation error/test error đều cao thì có nghĩa là model đang bị underfit</dd>
    <dd>- Underfitting xảy ra khi độ lệch quá lớn</dd>
    <dd>- Để khắc phục vấn đề này thì ta cần tăng thời gian học lên hoặc tăng chất lượng mô hình lên hoặc thay đổi mô hình khác,...</dd>
    <div class = 'center'>
      <img src="img/overfit.png">
      <br>
      <p>Ví dụ trực quan về overfit và underfit.</p>
    </div>
    <h4>
      11. Bias - Variance
    </h4>
      <div>
    <dt>Bias</dt>
    <dd>- nghĩa là độ lệch, biểu thị sự chênh lệch giữa giá trị trung bình mà mô hình dự đoán và giá trị thực tế của dữ liệu</dd>
    <dd>- Low bias: thì ít giả định về hàm mục tiêu</dd>
    <dd>- High bias: thì rất nhiều giả định về hàm mục tiêu và gây ra underfit và gây ra chi phí lỗi cao giữa cả 2 tập huấn luyện và tập kiểm tra</dd>
    <dt>Variance</dt>
    <dd>- nghĩa là phương sai, biểu thị độ phân tán của các giá trị mà mô hình dự đoán so với giá trị thực tế.</dd>
    <dd>- Model quá phức tạp và gây ra overfitting và chi phí lỗi trên tập huấn luyện thấp mà trên tập kiểm tra thì cao</dd>
    <dt>Trade off bias và phương sai</dt>
    <dd>- Các thuật toán học máy tuyến tính thường có độ chệch cao nhưng độ sai lệch thấp.</dd>
    <dd>- Các thuật toán học máy phi tuyến thường có độ chệch thấp nhưng độ sai lệch cao.</dd>
    <dd>- Không có gì thoát khỏi mối quan hệ giữa độ chệch và phương sai trong học máy. Tăng độ chệch sẽ làm giảm phương sai. Tăng phương sai sẽ làm giảm độ chệch.</dd>
    <dd>- Có một sự đánh đổi giữa hai mối quan tâm này và các thuật toán bạn chọn và cách bạn chọn để định cấu hình chúng đang tìm ra các số dư khác nhau trong sự đánh đổi này cho vấn đề của bạn. Trong thực tế, chúng tôi không thể tính toán các điều khoản sai lệch và phương sai thực sự bởi vì chúng tôi không biết chức năng đích cơ bản thực sự.
        Tuy nhiên, với tư cách là một khuôn khổ, độ chệch và phương sai cung cấp các công cụ để hiểu hành vi của các thuật toán học máy trong việc theo đuổi hiệu suất dự đoán.</dd>
          <div class = 'center'>
      <img src="img/bias_vaarr.jpg">
      <br>
      <p>Bias and Variance trade off</p>
    </div>
      </div>
      <h4>
      12. Gradient Descent
    </h4>
      <div>
      <p>
          - Gradient Descent là một thuật toán tối ưu khái quát, có khả năng tìm nghiệm tối ưu cho cho rất nhiều dạng bài toán. Ý tưởng chung của Hạ Gradient là liên tục điều chỉnh các tham số để cực tiểu hoá một hàm chi phí.<br>
          - Giả sử ta đang bị lạc trên núi trong sương mù dày, và chỉ có thể cảm nhận được độ dốc của mặt đất dưới chân. Một chiến lược tối ưu để xuống chân núi nhanh chóng là đi xuống theo hướng dốc nhất đây chính là GD sẽ thực hiện. : nó tính gradient cục bộ của hàm chi phí theo vector tham số , rồi đi theo hướng ngược với
gradient đó. Khi gradient bằng 0 tức là ta đã tới một điểm cực tiểu! <br>
          - Cụ thể hơn, ta bắt đầu bằng việc gán các giá trị ngẫu nhiên cho (đây được gọi là khởi tạo ngẫu nhiên — random initialization). Sau đó các giá trị này dần được cải thiện bằng cách đi từng bước nhỏ, mỗi bước cố gắng làm giảm hàm
chi phí (như MSE), cho đến khi thuật toán hội tụ tại điểm cực tiểu.
      </p>
          <div class = 'center'>
      <img src="img/gd.png">
      <br>
      <p>Hình minh họa Gradient Descent</p>
          </div>
          <p>
              - w &#8789; w - learning_rate * (dJ/dw) <br>
              - Có một tham số rất quan trọng trong GD đó là learning rate (tốc độ học). Nếu learning rate quá lớn thì có thể tới điểm hội tụi nhanh tuy nhiên nó sẽ có thể vượt quá điểm tối ưu và có thể dừng ở điểm local còn learning rate quá nhỏ thì nó mất nhiều thời gian để nó tới điểm hội tụ
          </p>
          <div class = 'center'>
              <img src="img/learning_rate.png">
              <br>
              <p>Hình minh họa learning rate trong GD</p>
          </div>
          <p>
              - Hàm lồi: nghĩa là đoạn thẳng nối hai điểm bất kỳ trên đường cong không bao giờ cắt đường cong đó và hàm lồi là 1 hàm liên tục. <br>
              - Hàm lồi rất tuyệt vời trong GD vì  việc đồ thị không có điểm cực tiểu mà chỉ có một giá trị nhỏ nhất vì vậy việc hội tụ sẽ nhanh hơn.<br>
              - Hàm MSE hay được sử dụng trong Regression là 1 hàm lồi.<br>
              - Tùy nhiên trong thực tế không phải hàm nào cũng là hàm lồi vì vậy cần tỉnh chỉnh phù hợp để tối ưu nhất con thể bằng cách tăng thời gian training hoặc nâng cấp thuật toán GD lên mometum hoặc RMSprop,...
              <br>
              - <a href="https://machinelearningcoban.com/2017/03/12/convexity/">Tham khảo về hàm lồi</a>
          </p>

          <div class = 'center'>
              <img src="img/convex_convex_non.png">
              <br>
              <p>Hàm lồi và hàm không lồi</p>
          </div>
          <p>
              Các biến thể của Gradient Descent:
              <dt>- Batch Gradient Descent</dt>
          <dd>- Để tính toán GD thì chúng ta tính toán dựa trên hàm chi phí và việc tính toán này thì BGD sẽ tính toán trên toàn bộ tập dữ liệu trong 1 epochs</dd>
          <dd>- Việc sử dụng toàn bộ data để huấn luyện nó sẽ làm cho thuật toán chạy rất là chậm rất lâu để hội tụ</dd>
          <dd>- Mặc dù thời gian training lâu nhưng nó luôn hướng về điểm mục tiêu và chi phí giảm dần theo vào lặp</dd>
          <dd>- Bên cạnh tìm learning rate cho phù hợp thì số vòng lặp cũng rất quan trọng</dd>
          <dd>- Dùng tất cả dữ liệu trong training set cho mỗi lần thực hiện bước tính đạo hàm (n)</dd>
          <div class = 'center'>
              <img src="img/batch_gd.jpeg">
              <br>
              <p>Cost vs Epochs (<a href="https://www.bogotobogo.com/python/scikit-learn/scikit-learn_batch-gradient-descent-versus-stochastic-gradient-descent.php">Source: https://www.bogotobogo.com/python/scikit-learn/scikit-learn_batch-gradient-descent-versus-stochastic-gradient-descent.php)</a></p>
              
          </div>
              <dt>- Stochastic Gradient Descent</dt>
          <dd>- Hạ Gradient Ngẫu nhiên (Stochastic Gradient Descent) lấy một mẫu (1) ngẫu nhiên trong tập huấn luyện tại mỗi bước và tính chỉ gradient dựa trên mẫu đó.</dd>
          <dd>- Làm việc với chỉ một mẫu dữ liệu giúp thuật toán chạy nhanh hơn vì chỉ cần xử lý rất ít dữ liệu tại mỗi vòng lặp. Điều này cũng giúp việc huấn luyện trên các tập dữ liệu lớn trở nên khả thi, vì chỉ cần một mẫu dữ liệu trong bộ
nhớ tại mỗi vòng lặp (SGD có thể được lập trình dưới dạng một thuật toán out-of-core</dd>
          <dd>- do tính chất ngẫu nhiên, thuật toán này không phổ biến bằng Hạ Gradient theo Batch: hàm chi phí thay vì giảm dần cho tới khi đạt cực tiểu, nó sẽ dao động lên xuống, dù nhìn chung có xu hướng giảm. Qua thời gian hàm
này sẽ dần tiến gần về cực tiểu, nhưng một khi đến đó nó sẽ tiếp tục dao động xung quanh chứ không hội tụ. Khi hội tụ thì tham số thì rất tốt nhưng chưa thực sự tối ưu</dd>
          <dd>- SGD nhờ đặc tính ngẫu nhiên có thể thoát ra khỏi cực tiểu địa phương, nên có khả năng đạt đến giá trị nhỏ nhất cao hơn Hạ Gradient theo Batch.</dd>
          <dd>- Do đó, sự ngẫu nhiên dù có thể giúp thoát khỏi điểm cực tiểu địa phương, nhưng cũng đồng nghĩa với việc không thể đạt được giá trị nhỏ nhất. Một giải pháp cho vấn đề này là từ từ giảm tốc độ học.</dd>
          <div class = 'center'>
              <img src="img/sdg.jpeg">
              <br>
              <p>Cost vs Epochs (<a href="https://adventuresinmachinelearning.com/stochastic-gradient-descent/">Cost vs Epochs in SGD (Source: https://adventuresinmachinelearning.com/stochastic-gradient-descent/)</a></p>
          </div>



          <dt>- Mini-batch Gradient Descent</dt>
          <dd>- : Tại mỗi bước, thay vì tính gradient dựa trên toàn bộ tập huấn luyện (như trong Hạ Gradient theo Batch) hoặc dựa trên chỉ một mẫu (như trong Hạ Gradient Ngẫu nhiên), Hạ Gradient theo Mini-batch thực hiện tính gradient trên một bộ nhỏ
các mẫu ngẫu nhiên được gọi là các mini-batch</dd>
          <dd>- Thuật toán này hoạt động tốt hơn nhiều SGD nhất là mini-batch khá lớn.</dd>
          <dd>- Tuy nhiên thuật toán này cũng khó vượt qua các điểm cực tiểu địa phương</dd>
          <dd>- Mini-batch cũng giống như SGD nó cũng xu hướng tiến tới điểm cực tiêu tuy nhiên hàm chí sẽ có thể tăng hoặc giảm liên tục và khi về điểm cực tiêu thì nó không dừng mà nhảy qua nhảy lại</dd>
          <dd>- Số lượng mẫu mini-batch sẽ được lấy ở khoảng 1 - n </dd>
          </p>
            <div class = 'center'>
              <img src="img/mini-batch.jpeg">
              <br>
              <p>Cost vs Epochs (<a href="https://stats.stackexchange.com/questions/310734/why-is-the-mini-batch-gradient-descents-cost-function-graph-noisy">Cost vs no of mini-batch (Source: https://stats.stackexchange.com/questions/310734/why-is-the-mini-batch-gradient-descents-cost-function-graph-noisy)</a></p>
          </div>
          </div>
    <h4>
      13. Loss function
    </h4>
      <div>
          <p>
              Các hàm tổn thất đóng một vai trò quan trọng trong bất kỳ mô hình thống kê nào - chúng xác định một mục tiêu mà hiệu suất của mô hình được đánh giá dựa trên và các tham số mà mô hình học được được xác định bằng cách giảm thiểu một hàm tổn thất đã chọn. Các hàm tổn thất xác định thế nào là một dự đoán tốt và không. Nói tóm lại, việc chọn đúng hàm tổn thất sẽ quyết định mức độ ổn định của công cụ ước tính của bạn.
          </p>
          <dt>Loss functions for regression</dt>
          <dd>
              - Mean Absolute Error (MAE)
          </dd>
          <dd>
              - Mean Squared Error (MSE)
          </dd>
          <dd>
              - Mean Bias Error (MBE)
          </dd>

          <dt>Loss functions for classification</dt>
          <dd>
              - Binary Cross Entropy Loss
          </dd>
          <dd>
              - Categorical Cross Entropy Loss
          </dd>
          <dd>
              - Hinge Loss
          </dd>
          <a href="https://www.section.io/engineering-education/understanding-loss-functions-in-machine-learning/">Tham Khảo về Loss Function</a>
      </div>
      <h4>
          14. Các phương thức đánh giá hiệu suất mô hình.
      </h4>
      <div>
          <dt>Regression</dt>
          <dd>- Để đánh giá hiệu suất của mô hình hồi quy chúng ta không đưa ra độ chính của mô hình mà chúng ta cần tính toán chi phí lỗi giữa giá trị thực tế và giá trị dự đoán</dd>
          <dt>Classification</dt>
          <dd>- Để đánh giá của mô hình phân loại thì chúng ta có rất nhiều phương thức để đánh giá</dd>


      </div>


  </article>
</section>

<footer>
  <p>Update sau nhé!!!!</p>
</footer>

</body>
</html>

